<html><head>
    <title>{CRATE_NAME}</title>
    <style>
        #console {
            background:     #000;
            color:          #FFF;
            white-space:    pre-wrap;
            display:        block;
            width:          100em;
            min-height:     50em;
            text-align:     left;
            padding:        0.2em 0.5em;
        }

        @keyframes blink {
            0%      { opacity: 60%; }
            50%     { opacity: 40%; }
            100%    { opacity: 60%; }
        }

        #cursor {
            animation:      blink 800ms step-start infinite;
            border-bottom:  3px solid #FFF;
        }
    </style>
</head><body>
    <center>
        <h1>{CRATE_NAME}</h1>
        <code id="console"><span id="cursor"> </span></code>
    </center>
    <script>
        const ATOMIC_STDIN_FILLED   = 0;
        const ATOMIC_STDIN_CONSUMED = 1;
        const ATOMIC_COUNT = 2;

        const STDIN_BITS = 10;
        const STDIN_COUNT = (1 << STDIN_BITS);
        const STDIN_MASK = STDIN_COUNT-1;

        function exec_base64_wasm(data, wasm) {
            var memory;

            const {atomic_sab, stdin_sab} = data;
            const atomic    = new Int32Array(atomic_sab);
            const stdin     = new Uint8Array(stdin_sab);

            // References:
            // https://docs.rs/wasi-types/0.1.5/src/wasi_types/lib.rs.html
            // https://docs.rs/wasi/0.10.2+wasi-snapshot-preview1/src/wasi/lib_generated.rs.html
            // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md

            // https://docs.rs/wasi/0.10.2+wasi-snapshot-preview1/src/wasi/lib_generated.rs.html#27
            const ERRNO_SUCCESS     = 0;
            const ERRNO_BADF        = 8;
            const ERRNO_NOTCAPABLE  = 76;

            function nyi() {
                //debugger;
                return ERRNO_NOTCAPABLE;
            }

            function args_get                   () { return nyi(); }
            function args_sizes_get             () { return nyi(); }
            function environ_get                () { return nyi(); }
            function environ_sizes_get          () { return nyi(); }
            function clock_res_get              () { return nyi(); }
            function clock_time_get             () { return nyi(); }
            function fd_advise                  () { return nyi(); }
            function fd_allocate                () { return nyi(); }
            function fd_close                   () { return nyi(); }
            function fd_datasync                () { return nyi(); }
            function fd_fdstat_get              () { return nyi(); }
            function fd_fdstat_set_flags        () { return nyi(); }
            function fd_fdstat_set_rights       () { return nyi(); }
            function fd_filestat_get            () { return nyi(); }
            function fd_filestat_set_size       () { return nyi(); }
            function fd_filestat_set_times      () { return nyi(); }
            function fd_pread                   () { return nyi(); }
            function fd_prestat_get             () { return nyi(); }
            function fd_prestat_dir_name        () { return nyi(); }
            function fd_pwrite                  () { return nyi(); }

            function fd_read(fd, iovec_array_ptr, iovec_array_len, nread_ptr) {
                // https://docs.rs/wasi/0.10.2+wasi-snapshot-preview1/src/wasi/lib_generated.rs.html#1754

                var dv = new DataView(memory.buffer);
                var nread = 0;
                var errno = ERRNO_SUCCESS;

                for (var iovec_idx = 0; iovec_idx < iovec_array_len; ++iovec_idx) {
                    var buf_ptr = dv.getUint32(iovec_array_ptr + (8 * iovec_idx) + 0, true);
                    var buf_len = dv.getUint32(iovec_array_ptr + (8 * iovec_idx) + 4, true);
                    if (buf_len <= 0) { continue; }

                    switch (fd) {
                        case 0: // stdin
                            for (;;) {
                                var consumed    = Atomics.load(atomic, ATOMIC_STDIN_CONSUMED);
                                while (Atomics.wait(atomic, ATOMIC_STDIN_FILLED, consumed) !== "ok") {}
                                var filled      = Atomics.load(atomic, ATOMIC_STDIN_FILLED);
                                var available   = (filled-consumed)|0; // available *to read*
                                console.assert(available > 0);
                                var n = Math.min(available, buf_len);

                                for (var i=0; i<n; ++i) {
                                    var b = stdin[(i+consumed)&STDIN_MASK];
                                    self.postMessage({ kind: "console", text: new TextDecoder().decode(new Uint8Array([b])) }); // XXX: local echo
                                    dv.setUint8(buf_ptr+i, b);
                                }
                                Atomics.store(atomic, ATOMIC_STDIN_CONSUMED, (consumed+n)|0);

                                nread += n;
                                break;
                            }
                            break;
                        default:
                            errno = ERRNO_BADF;
                            break;
                    }
                }

                dv.setUint32(nread_ptr, nread, true);
                return errno;
            }

            function fd_readdir                 () { return nyi(); }
            function fd_renumber                () { return nyi(); }
            function fd_seek                    () { return nyi(); }
            function fd_sync                    () { return nyi(); }
            function fd_tell                    () { return nyi(); }

            function fd_write(fd, ciovec_array_ptr, ciovec_array_len, nwritten_ptr) {
                // https://docs.rs/wasi/0.10.2+wasi-snapshot-preview1/src/wasi/lib_generated.rs.html#1796
                // https://nodejs.org/api/wasi.html

                var dv = new DataView(memory.buffer);
                var nwritten = 0;
                var errno = ERRNO_SUCCESS;

                var text = "";
                for (var ciovec_idx = 0; ciovec_idx < ciovec_array_len; ++ciovec_idx) {
                    var buf_ptr = dv.getUint32(ciovec_array_ptr + (8 * ciovec_idx) + 0, true);
                    var buf_len = dv.getUint32(ciovec_array_ptr + (8 * ciovec_idx) + 4, true);

                    switch (fd) {
                        case 1: // stdout
                        case 2: // stderr
                            text += new TextDecoder().decode(new DataView(memory.buffer, buf_ptr, buf_len));
                            nwritten += buf_len;
                            break;
                        default:
                            errno = ERRNO_BADF;
                            break;
                    }
                }

                if (text !== "") {
                    self.postMessage({ kind: "console", text });
                }

                dv.setUint32(nwritten_ptr, nwritten, true);
                return errno;
            }

            function path_create_directory      () { return nyi(); }
            function path_filestats_get         () { return nyi(); }
            function path_filestat_set_times    () { return nyi(); }
            function path_link                  () { return nyi(); }
            function path_open                  () { return nyi(); }
            function path_readlink              () { return nyi(); }
            function path_remove_directory      () { return nyi(); }
            function path_rename                () { return nyi(); }
            function path_symlink               () { return nyi(); }
            function path_unlink_file           () { return nyi(); }
            function poll_oneoff                () { return nyi(); }

            function proc_exit(code) {
                // https://docs.rs/wasi/0.10.2+wasi-snapshot-preview1/src/wasi/lib_generated.rs.html#1901
                self.postMessage({ kind: "proc_exit", code });
                throw "exit";
            }

            function proc_raise                 () { return nyi(); }
            function sched_yield                () { return nyi(); }
            function random_get                 () { return nyi(); }
            function sock_recv                  () { return nyi(); }
            function sock_send                  () { return nyi(); }
            function sock_shutdown              () { return nyi(); }

            const imports = {
                wasi_snapshot_preview1: {
                    args_get,
                    args_sizes_get,
                    environ_get,
                    environ_sizes_get,
                    clock_res_get,
                    clock_time_get,
                    fd_advise,
                    fd_allocate,
                    fd_close,
                    fd_datasync,
                    fd_fdstat_get,
                    fd_fdstat_set_flags,
                    fd_fdstat_set_rights,
                    fd_filestat_get,
                    fd_filestat_set_size,
                    fd_filestat_set_times,
                    fd_pread,
                    fd_prestat_get,
                    fd_prestat_dir_name,
                    fd_pwrite,
                    fd_read,
                    fd_readdir,
                    fd_renumber,
                    fd_seek,
                    fd_sync,
                    fd_tell,
                    fd_write,
                    path_create_directory,
                    path_filestats_get,
                    path_filestat_set_times,
                    path_link,
                    path_open,
                    path_readlink,
                    path_remove_directory,
                    path_rename,
                    path_symlink,
                    path_unlink_file,
                    poll_oneoff,
                    proc_exit,
                    proc_raise,
                    sched_yield,
                    random_get,
                    sock_recv,
                    sock_send,
                    sock_shutdown,
                },
            };

            const binary = atob(wasm);
            const typedarray = new Uint8Array(binary.length);
            for (var i=0; i<binary.length; ++i) { typedarray[i] = binary.charCodeAt(i); }

            WebAssembly.compile(typedarray).then(function (m) {
                if (false) {
                    WebAssembly.Module.imports(m).forEach(function (imp) {
                        console.log("import", imp);
                    });
                    WebAssembly.Module.exports(m).forEach(function (exp) {
                        console.log("export", exp);
                    });
                }
                return WebAssembly.instantiate(m, imports);
            }).then(function (m) {
                memory = m.exports.memory;
                try {
                    m.exports.main();
                    proc_exit(0);
                } catch (e) {
                    if (e !== "exit") {
                        console.error(e);
                        debugger;
                        throw e;
                    }
                } finally {
                    self.close();
                }
            });
        }

        function worker() {
            self.onmessage = function(e) {
                switch (e.data.kind) {
                    case "init":
                        exec_base64_wasm(e.data, {BASE64_WASM32});
                        break;
                    default:
                        console.error("unexpected event kind", e.kind);
                        debugger;
                        break;
                }
            };
        }

        function main() {
            const con       = document.getElementById("console");
            const cursor    = document.getElementById("cursor");

            const atomic_sab    = new SharedArrayBuffer(4 * ATOMIC_COUNT);
            const atomic        = new Int32Array(atomic_sab);
            const stdin_sab     = new SharedArrayBuffer(STDIN_COUNT);
            const stdin         = new Uint8Array(stdin_sab);

            // spawn web worker
            const blob = new Blob(Array.prototype.map.call(document.querySelectorAll('script:not([data-js-worker=\'false\'])'), function (oScript) { return oScript.textContent; }),{type: 'text/javascript'});
            document.worker = new Worker(window.URL.createObjectURL(blob));
            document.worker.onmessage = function(e) {
                e = e.data;
                switch (e.kind) {
                    case "console":
                        con.insertBefore(document.createTextNode(e.text), cursor);
                        break;
                    case "proc_exit":
                        var exit = document.createElement("span");
                        exit.textContent = `\nprocess exited with code ${e.code}`;
                        exit.style.color = "#888";
                        con.insertBefore(exit, cursor);
                        con.removeChild(cursor);
                        break;
                    default:
                        console.error("unexpected event kind", e.kind);
                        debugger;
                        break;
                }
            };
            document.worker.postMessage({
                kind:       "init",
                atomic_sab,
                stdin_sab,
            });

            var stdin_buffer = [];
            document.addEventListener("keypress", function(e) {
                var chars = e.char || String.fromCharCode(e.charCode);
                if (chars === "\r") { chars = "\n"; }
                var chars = new TextEncoder().encode(chars);
                for (var i=0; i<chars.length; ++i) {
                    stdin_buffer.push(chars[i]);
                }
            });

            setInterval(function(){
                if (stdin_buffer.length === 0) return;

                var filled      = Atomics.load(atomic, ATOMIC_STDIN_FILLED);
                var consumed    = Atomics.load(atomic, ATOMIC_STDIN_CONSUMED);
                var available   = STDIN_COUNT - ((filled-consumed)|0); // available *to write*

                var n = Math.min(available, stdin_buffer.length);
                for (var i=0; i<n; ++i) {
                    stdin[(i+filled)&STDIN_MASK] = stdin_buffer[i];
                }
                stdin_buffer.splice(0, n);
                filled = (filled+n)|0;
                Atomics.store(atomic, ATOMIC_STDIN_FILLED, filled);
                Atomics.notify(atomic, ATOMIC_STDIN_FILLED);
            }, 0);
        }
    </script>
    <script data-js-worker="true" type="text/js-worker-only">worker();</script>
    <script data-js-worker="false">main();</script>
</body></html>
